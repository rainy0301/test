# coding=utf8
# Author: Jingcheng Qiu


from __future__ import print_function, absolute_import, division
import os
import sys
import string
import logging
import math
from datetime import datetime
import pandas as pd
import numpy as np
import scipy.stats
import matplotlib
import matplotlib.pyplot as plt
from sklearn import tree
import contingency as cy  # external package，需要和本文件放在同一目录下


# 显示中文的字体
if sys.version_info.major == 2:
    stdi, stdo, stde = sys.stdin, sys.stdout, sys.stderr
    reload(sys)
    sys.setdefaultencoding('utf-8')
    sys.stdin, sys.stdout, sys.stderr = stdi, stdo, stde
try:
    path_abs = os.path.dirname(os.path.realpath(__file__)) + '/'
    zhfont = matplotlib.font_manager.FontProperties(fname=path_abs + "ukai.ttc")
except Exception:
    print("cannot find zhfont")
    zhfont = matplotlib.font_manager.FontProperties()



def str_convert(x):
    '''
    统一unicode和str类型，主要是py2使用
    '''
    if type(x) in [int, float, np.float64]:
        return str(int(x))
    elif type(x) is str:
        return x
    elif type(x) is unicode:
        return code.encode('utf8')
    else:
        return x


def value_match(map_dict, key_list):
    '''
    根据categorical变量的map dict对index对应的值做匹配 eg:[1,3,4,5] → ['本科','大专','高中','研究生']
    Args:
        map_dict: dict
        key_list: list
    Return:
        result: list
    '''
    result = []
    for key in key_list:
        if key in map_dict:
            result.append(map_dict[key])
        else:
            result.append('base')
    return result


def woe_calc(bad, good, goodfreq, badfreq):
    '''
    计算woe值
    Args:
        bad: int or float, 单个bin中target=1的样本数
        good: int or float, 单个bin中target=0的样本数
        goodfreq: int or float, 所有样本中target=0的样本数
        badfreq: int or float, 所有样本中target=1的样本数
    Return:
        woe: float
    '''
    target_rt = bad / float(badfreq)
    non_target_rt = good / float(goodfreq)
    if float(bad) != 0.0 and bad / float(bad + good) != 1.0:
        woe = math.log(float(target_rt / non_target_rt))
    elif target_rt == 0.0:
        woe = -99999999.0
    elif bad / float(bad + good) == 1.0:
        woe = 99999999.0

    return woe


def iv_calc(ds):
    '''
    计算变量的iv值
    Args:
        ds: DataFrame
    Return:
        iv: float, iv值
    '''
    bad_dist = ds['1'] / float(ds['1'].sum())
    good_dist = ds['0'] / float(ds['0'].sum())
    bad_dist = bad_dist.apply(lambda x: 0.0001 if x == 0 else x)
    ds['iv'] = (bad_dist - good_dist) * np.log(bad_dist / good_dist)
    iv = ds['iv'].sum()

    return iv


def target_check(df_master, target):
    '''
    检查target是否正确，理论上target应该只有0和1
    Args:
        df_master: DataFrame
        target: string, target列名
    '''
    # 检查target是否只有0和1两个取值
    if set(df_master[target].unique()) != {0, 1}:
        raise ValueError('Target are not only 0 and 1!')


def init_binning(df_master, var_name, target, max_bin_num=200, missing=False, cut_points=None):
    '''
    对数值型变量进行切bin，返回每个bin中target的分布情况和切bin的区间
    Args:
        df_master: DataFrame
        var_name: string, 变量名
        target: string, target列名
        max_bin_num: 切bin的最大数量，默认为200个
        missing: bool, 变量是否有缺失，默认为False
        cut_points: list or array-like, 指定的切分点，默认为None
    Return:
        ds: DataFrame, 每个bin的统计信息
    Raise:
        ValueError
    '''
    df_tmp = df_master[[var_name, target]].copy()

    # 初始化切分点
    if cut_points is not None:
        if len(cut_points) == 0:
            raise ValueError('wrong cut points: {0}'.format(var_name))
        if np.max(df_tmp[var_name]) > cut_points[-1]:
            cut_points[-1] = np.max(df_tmp[var_name])  # bins最后一个值改为max value, 防止忘记填最大值
        if np.min(df_tmp[var_name]) < cut_points[0]:
            cut_points[0] = np.min(df_tmp[var_name])  # bins第一个值改为min value, 防止忘记填最小值

    # 若变量的unique value < max_bin_num，则每个value一个bin
    elif len(df_tmp[var_name].unique()) < max_bin_num:
        uvalue = np.sort(df_tmp[var_name].unique())
        uvdiff = np.append(np.diff(uvalue) / 2.0, 0)
        cut_points = np.append(uvalue.min(), uvalue + uvdiff)
    # 若变量的unique value >= max_bin_num, 则根据分位点切max_bin_num个bin
    else:
        uvalue = np.empty(0)
        for i in np.arange(max_bin_num + 1):
            uvalue = (np.append(uvalue, df_tmp[var_name].quantile(float(i) / max_bin_num)))
        uvalue = np.unique(uvalue)
        uvdiff = np.append(np.diff(uvalue) / 2.0, 0)
        cut_points = np.append(uvalue.min(), uvalue + uvdiff)

    # 当指定了变量存在缺失时，把-1.0单独放在一个bin中
    if missing == True:
        if cut_points[0] == -1.0:
            tmp_ary1 = np.asarray([-1.0, -0.5])
            tmp_ary2 = np.asarray(cut_points[1:])
            cut_points = np.concatenate((tmp_ary1, tmp_ary2), axis=0)
        else:
            logging.warning('Expect variable has missing value but actually no missing')
    # 分bin
    cut_points = np.unique(cut_points)
    intervals = pd.cut(df_tmp[var_name], bins=cut_points, retbins=True, include_lowest=True, precision=18)[0].astype(str)
    df_tmp[var_name + '_bin'] = [tuple([float(j) for j in i.strip('([]').split(',')]) for i in intervals]

    # 计算每个bin中target的分布
    ds = df_tmp.groupby(var_name + '_bin')[target].value_counts().unstack().fillna(value=0)
    ds['total'] = ds[0] + ds[1]
    ds['bin'] = [[i[0], i[1]] for i in list(ds.index)]
    ds['bin_lb'] = [i[0] for i in list(ds.index)]
    ds['bin_lb'] = ds['bin_lb'].astype(float)
    ds = ds.sort_values(by='bin_lb', axis=0, ascending=True).reset_index(drop=True)  # 根据bin的下界进行排序
    ds.columns = ['0', '1', 'total', 'bin', 'bin_lb']

    return ds


def mergebin(ds, idx_list, idx, var_type):
    '''
    合并相邻的bin，并重新计算合并后bin的统计信息和卡方值
    Args:
        ds: DataFrame
        idx_list: list, index list
        idx: int, 待合并的bin在index list中的位置
        var_type: str, 变量类型
    Return:
        ds: DataFrame
    '''
    # 合并两个bin，重新计算bin的0-1分布
    ds.at[idx_list[idx], ['0', '1']] = ds.loc[idx_list[idx], ['0', '1']] + ds.loc[idx_list[idx+1], ['0', '1']]
    ds.at[idx_list[idx], 'total'] = ds.loc[idx_list[idx], 'total'] + ds.loc[idx_list[idx+1], 'total']
    # 重新计算bin的范围
    if var_type == 'numerical':
        ds.at[idx_list[idx], 'bin'] = [ds.loc[idx_list[idx], 'bin'][0], ds.loc[idx_list[idx+1], 'bin'][1]]
    elif var_type == 'categorical':
        ds.at[idx_list[idx], 'bin'] = ds.loc[idx_list[idx:idx+2], 'bin'].sum()
    ds = ds.drop(idx_list[idx+1], axis=0)        # 删除被合并的bin
    idx_list.pop(idx+1)      # 从index list中删除被合并的bin的index

    # 重新计算合并后的bin与前后两个bin的卡方值
    # 若不是第一个bin，则计算与前一个bin的卡方值
    if idx != 0:
        ds.at[idx_list[idx-1], 'chisq'] = cy.chi2_contingency(ds.loc[idx_list[(idx-1):(idx+1)], ['0', '1']])[0]
    # 若不是最后一个bin，则计算与后一个bin的卡方值，否则卡方值赋值成无穷大
    if idx < ds.shape[0] - 1:
        ds.at[idx_list[idx], 'chisq'] = cy.chi2_contingency(ds.loc[idx_list[idx:idx+2], ['0', '1']])[0]
    else:
        ds.at[idx_list[idx], 'chisq'] = 9999999.0

    return ds


def gene_reference(ds, var_name, var_type):
    '''
    生成变量的woe reference table
    Args:
        ds: DataFrame
        var_name: string, 变量名
        var_type: string, 变量类型, numerical or categorical
    Return:
        df_ref_table: DataFrame, reference table
    '''
    # 计算每个bin的woe和iv值
    goodfreq = ds['0'].sum()
    badfreq = ds['1'].sum()
    ds['woe_value'] = ds.apply(lambda x: woe_calc(x['1'], x['0'], goodfreq, badfreq), axis=1)
    iv = iv_calc(ds)

    # 生成reference table
    df_ref_table = pd.DataFrame(columns=['Var_Name', 'Var_Type', 'Bin_No', 'Var_Value', 'Ref_Value',
                                         'Count_0', 'Count_1', 'Total', 'Target_Rate', 'Proportion', 'IV'])
    df_ref_table['Bin_No'] = range(1, ds.shape[0] + 1)  # Bin的编号，从1开始
    df_ref_table['Var_Value'] = ds['bin'].astype(str)  # 将list转成字符串
    df_ref_table['Ref_Value'] = ds['woe_value']
    df_ref_table['Count_0'] = ds['0']
    df_ref_table['Count_1'] = ds['1']
    df_ref_table['Total'] = ds['total']
    df_ref_table['Target_Rate'] = df_ref_table['Count_1'] / df_ref_table['Total'].astype(float)
    df_ref_table['Proportion'] = (df_ref_table['Count_1'] + df_ref_table['Count_0']) / float(ds['total'].sum())
    df_ref_table['IV'] = iv
    df_ref_table['Var_Name'] = var_name
    df_ref_table['Var_Type'] = var_type

    return df_ref_table


def get_list_str(x):
    '''
    取categorical 变量的Var_Value,三个为一排排列
    '''
    str_list = x.split('\001')
    string = ''
    for i in range(len(str_list)):
        string += str_list[i] + ','
        if (i + 1) % 3 == 0 and i + 1 != len(str_list):
            string += '\n'

    return string[:-1]


def plot_reference(df_ref, save_path=None, figsize=(10, 4)):
    '''
    根据reference table绘制变量的woe图
    Args:
        df_ref: DataFrame, reference table
        save_path: string, 图片存放路径
    '''
    x = np.arange(df_ref.shape[0])
    y = df_ref['Ref_Value'].values
    z = df_ref['Target_Rate'].values

    # 设置图片的大小
    plt.figure(figsize=figsize)
    # 绘制每个bin中的0、1样本数量的柱状图
    plt.bar(x, df_ref['Total'].values, color='b', label='0', align='center')
    plt.bar(x, df_ref['Count_1'].values, color='r', label='1', align='center')

    # 绘制横坐标的label
    if df_ref['Var_Type'].iloc[0] == 'numerical':
        xticks_list = df_ref['Var_Value'].values
        xticks_list = [tuple([float(j) for j in i.strip('([] ').split(',')]) for i in xticks_list]
        xticks_list = [[round(i[0], 4), round(i[1], 4)] for i in xticks_list]
        plt.xticks(x, xticks_list)
    if df_ref['Var_Type'].iloc[0] == 'categorical':
        xticks_list = df_ref['Var_Value'].apply(get_list_str).tolist()
        plt.xticks(x, xticks_list, fontproperties=zhfont)
    plt.ylabel('Sample count')
    plt.legend(loc=2, fontsize=7)

    # 绘制每个bin的woe值的折线图
    ax2 = plt.twinx()
    plt.plot(x, y, '.-k', linewidth=2, markersize=8)
    for i, j, k in zip(x, y, z):
        ax2.annotate('%.2f(%.2f%%)' % (j, k*100),
                     xy=(i, j), va="center", ha="center",
                     bbox=dict(boxstyle="round", fc="w"))
    plt.ylabel('Woe value(Target rate)')
    plt.title('{0}: IV={1}'.format(df_ref['Var_Name'].iloc[0], round(df_ref['IV'].iloc[0], 5)))

    # 保存图片
    if save_path is not None:
        plt.savefig(save_path + '/' + df_ref['Var_Name'].iloc[0], bbox_inches='tight')
    plt.show()
    plt.close()


def numwoe_autobinning(df_master, var_name, target, max_bin_num=200, max_bins=6, missing=True, method='chisq',
                       to_plot=True, save_path=None):
    '''
    对numerical变量进行自动分bin并计算woe和iv值，可选通过卡方值和信息熵的方式对变量进行分bin
    Args:
        df_master: DataFrame
        var_name: str, 变量名
        target: string, target列名
        max_bin_num: int, 初始分bin的最大分bin个数，根据样本数量和unique value来决定，默认为200
        max_bins: int, 最大分bin个数, 默认为6个
        missing: bool, 是否有缺失值，默认为True，目前只支持把-1当做缺失值
        method: str, 可选'chisq' 或者 'entropy'
        to_plot: bool, 是否绘制reference图, 默认为True
        save_path: str, 图片存放路径, 默认为None, 即不保存
    Return:
        df_ref_table: DataFrame, woe reference table
    '''
    target_check(df_master, target)    # 检查target是否正确
    min_samples = int(df_master.shape[0] / 20.0)  # 设置每个bin中样本数的最小值，每个bin的最小样本个数为n/20

    if method == 'chisq':
        ds = init_binning(df_master, var_name=var_name, target=target, max_bin_num=max_bin_num, missing=missing)

        # 计算相邻两个bin的卡方值
        chisq = []
        for i in range(ds.shape[0] - 1):
            chisq.append(cy.chi2_contingency(ds.iloc[[i, i + 1], [0, 1]])[0])
        chisq.append(9999999.0)  # 最后一个bin的卡方值赋值为无穷大
        ds['chisq'] = chisq

        # 把missing值单独作为一个bin
        if missing == True:
            if ds[ds['bin_lb'] == -1.0].shape[0] > 0:
                ds_miss = ds[ds['bin_lb'] == -1.0].copy()
                ds = ds[ds['bin_lb'] != -1.0]
            else:
                ds_miss = pd.DataFrame()

        # 合并卡方值较小的两个bin
        ds_idx_list = list(ds.index)
        while (ds.shape[0] > max_bins) | (ds['chisq'].min() <= scipy.stats.chi2.ppf(0.95, 1)):
            # 找到卡方值最小的bin的index在index list中的位置
            k = ds_idx_list.index(ds['chisq'].idxmin())
            ds = mergebin(ds, idx_list=ds_idx_list, idx=k, var_type='numerical')

        # 限制每个bin的最小样本个数
        while ds['total'].min() < min_samples:
            # 找到样本个数最少的bin
            k = ds_idx_list.index(ds['total'].idxmin())
            # 如果与前一个bin的卡方值比后一个bin的卡方值小，则选择与前一个bin合并
            if (k == len(ds_idx_list) - 1) | (ds.loc[ds_idx_list[k], 'chisq'] > ds.loc[ds_idx_list[k - 1], 'chisq']):
                k -= 1
            ds = mergebin(ds, idx_list=ds_idx_list, idx=k, var_type='numerical')

    elif method == 'entropy':
        max_depth = int(math.log(max_bins, 2))
        if missing == True:
            df_miss = df_master.loc[df_master[var_name] == -1.0, [var_name, target]].reset_index(drop=True)
            df_no_miss = df_master.loc[df_master[var_name] != -1.0, [var_name, target]].reset_index(drop=True)
            if df_miss.shape[0] > 0:
                ds_miss = init_binning(df_miss, var_name=var_name, target=target, cut_points=[-1.0,-0.5], missing=False)
            else:
                ds_miss = pd.DataFrame()
            min_value = -0.5
        else:
            df_no_miss = df_master
            min_value = df_no_miss[var_name].min()
        clf = tree.DecisionTreeClassifier(criterion='entropy', max_depth=max_depth, min_samples_leaf=min_samples)
        clf.fit(df_no_miss[var_name].values.reshape(-1, 1), df_no_miss[target])
        cut_points = np.sort(clf.tree_.threshold[clf.tree_.threshold != -2.0])
        cut_points = np.append([min_value], cut_points)
        cut_points = np.append(cut_points, df_no_miss[var_name].max())
        ds = init_binning(df_no_miss, var_name=var_name, target=target, cut_points=cut_points, missing=False)

    else:
        raise ValueError('wrong method, only choose "chisq" or "entropy"!')

    # 生成最终的reference table
    if missing == True:
        ds = pd.concat([ds_miss, ds])
    ds = ds.reset_index(drop=True)
    df_ref_table = gene_reference(ds, var_name=var_name, var_type='numerical')

    # 画图
    if to_plot == True:
        plot_reference(df_ref_table, save_path=save_path)

    return df_ref_table


def numwoe_aptbinning(df_master, var_name, target, bins, to_plot=True, save_path=None):
    '''
    根据指定的切bin区间对数值型变量进行分bin并计算woe和iv值
    Args:
        df_master: DataFrame
        var_name: str, 变量名
        target: string, target列名
        bins: list or array-like, 指定的切分点，eg. [0.0, 1.0, 3.0, 10.0]
        to_plot: bool, 是否绘制reference图, 默认为True
        save_path: str, 图片存放路径, 默认为None, 即不保存
    Return:
        df_ref_table: DataFrame, woe reference table
    '''
    target_check(df_master, target)
    ds = init_binning(df_master, var_name=var_name, target=target, cut_points=bins, missing=False)
    df_ref_table = gene_reference(ds, var_name=var_name, var_type='numerical')
    if to_plot == True:
        plot_reference(df_ref_table, save_path=save_path)

    return df_ref_table


def catwoe_autobinning(df_master, var_name, target, max_bins=6, min_samples_bin=1, missing_value='-1', to_plot=True,
                       save_path=None):
    '''
    对categorical变量进行自动分bin并计算woe和iv值
    Args:
        df_master: DataFrame
        var_name: str, 变量名
        target: string, target列名
        min_samples_bin: int, 初始分bin时的最小样本个数，将样本数小于min_samples_bin的变量取值合并到一个bin中，默认为1
        missing_value: string, 指定缺失值，分bin时会把该值单独分到一个bin，默认为None
        to_plot: bool, 是否绘制reference图, 默认为True
        save_path: str, 图片存放路径, 默认为None, 即不保存
    Return:
        df_ref_table: DataFrame, woe reference table
    '''
    target_check(df_master, target)  # 检查target是否正确

    ds = pd.crosstab(df_master[var_name], df_master[target]).fillna(value=0).reset_index(drop=False)
    ds['total'] = ds[1] + ds[0]
    ds['bin'] = [[i] for i in ds.index]  # 给每个bin编号
    ds.columns = ['value', '0', '1', 'total', 'bin']
    map_dict = dict(zip(ds.index, ds['value']))  # 生成每个编号与真实取值的映射

    # 把缺失值单独作为一个bin
    if missing_value is not None:
        ds_miss = ds[ds['value'] == missing_value].copy()
        ds = ds[ds['value'] != missing_value]

    ds = ds.sort_values(by=['total'], ascending=True)  # 根据每个bin中的样本个数排序

    # 合并样本数量过小的bin
    idx_small_bin = list(ds[ds['total'] < min_samples_bin].index)
    if len(idx_small_bin) >= 2:
        ds.at[idx_small_bin[0], ['0', '1']] = ds.loc[idx_small_bin, ['0', '1']].sum()
        ds.at[idx_small_bin[0], 'total'] = ds.loc[idx_small_bin, 'total'].sum()
        ds.at[idx_small_bin[0], 'bin'] = idx_small_bin
        ds = ds.drop(idx_small_bin[1:], axis=0)

    # 计算每个bin的target rate
    ds['target_rt'] = ds['1'] / (ds['0'] + ds['1'])
    ds = ds.sort_values(by='target_rt', ascending=True)  # 根据每个bin中的target rate排序

    # 计算相邻两个bin的卡方值
    chisq = []
    for i in range(ds.shape[0] - 1):
        try:
            chisq.append(cy.chi2_contingency(ds.iloc[[i, i + 1], [1, 2]])[0])
        except:
            chisq.append(cy.chi2_contingency(ds.iloc[[i, i + 1], [0, 1]])[0])
    chisq.append(9999999.0)
    ds['chisq'] = chisq

    # 循环合并相邻两个bin，重新计算与前后两个bin的卡方值
    ds_idx_list = list(ds.index)
    while (ds.shape[0] > max_bins) | (ds.chisq.min() <= scipy.stats.chi2.ppf(0.95, 1)):
        k = ds_idx_list.index(ds['chisq'].idxmin())
        ds = mergebin(ds, idx_list=ds_idx_list, idx=k, var_type='categorical')

    # 限制每个bin的最小样本数
    min_samples = df_master.shape[0] / 20.0  # 设置每个bin中样本数的最小值
    while ds['total'].min() < min_samples:
        # 找到样本个数最少的bin
        k = ds_idx_list.index(ds['total'].idxmin())
        if (k == len(ds_idx_list) - 1) | (ds.loc[ds_idx_list[k], 'chisq'] > ds.loc[ds_idx_list[k - 1], 'chisq']):
            k -= 1
        ds = mergebin(ds, idx_list=ds_idx_list, idx=k, var_type='categorical')

    # 生成reference table
    if missing_value is not None:
        ds = pd.concat([ds_miss, ds])
    ds = ds.reset_index(drop=True)
    ds['bin'] = ds['bin'].apply(lambda x: value_match(map_dict, x))  # 将索引还原成变量原本的取值
    ds['bin'] = ds['bin'].apply(lambda x: '\001'.join(x))  # 用特殊符号'\001'拼接value，防止出现value中有标点符号
    df_ref_table = gene_reference(ds, var_name=var_name, var_type='categorical')

    # 画图
    if to_plot == True:
        plot_reference(df_ref_table, save_path=save_path)

    return df_ref_table


def catwoe_aptbinning(df_master, var_name, target, bins, to_plot=True, save_path=None):
    '''
    根据指定的分bin方式对categorical变量进行分bin，并计算WOE
    Args:
        df_master: DataFrame
        var_name: str, 变量名
        target: string, target列名
        bins: list, 分组规则，eg. [['初中', '高中'], ['大专', '本科', '硕士研究生'], ['博士研究生']]
        to_plot: bool, 是否绘制reference图, 默认为True
        save_path: str, 图片存放路径, 默认为None, 即不保存
    Return:
        df_ref_table: DataFrame, woe reference table
    '''
    unique_values = set(sum(bins, []))
    if len(unique_values) != len(sum(bins, [])):
        raise ValueError('Value is repetitive, please check bins is correct')

    ds = pd.crosstab(df_master[var_name], df_master[target]).fillna(value=0).reset_index(drop=False)
    ds['total'] = ds[1] + ds[0]
    ds.columns = ['bin', '0', '1', 'total']

    # 根据指定的分bin方式分bin
    for bin in bins:
        idx_list = []
        for value in bin:
            idx_list.append(int(ds[ds['bin'] == value].index.values))
        ds.at[idx_list[0], ['0', '1']] = ds.loc[idx_list, ['0', '1']].sum()
        ds.at[idx_list[0], 'total'] = ds.loc[idx_list, 'total'].sum()
        ds.at[idx_list[0], 'bin'] = bin
        ds = ds.drop(idx_list[1:], axis=0)
    ds = ds.reset_index(drop=True)

    # 生成reference table
    ds['bin'] = ds['bin'].apply(lambda x: '\001'.join(x))  # 用特殊符号'\001'拼接value，防止出现value中有标点符号
    df_ref_table = gene_reference(ds, var_name=var_name, var_type='categorical')

    # 画图
    if to_plot == True:
        plot_reference(df_ref_table, save_path=save_path)

    return df_ref_table


def catwoe_isobinning(df_master, var_name, target, to_plot=True, save_path=None):
    '''
    对categorical变量计算WOE，每个value单独一个bin
    Args:
        df_master: DataFrame
        var_name: str, 变量名
        target: string, target列名
        to_plot: bool, 是否绘制reference图, 默认为True
        save_path: str, 图片存放路径, 默认为None, 即不保存
    Return:
        df_ref_table: DataFrame, woe reference table
    '''
    target_check(df_master, target)  # 检查target是否正确

    # 每个value单独一个bin
    ds = pd.crosstab(df_master[var_name], df_master[target]).fillna(value=0).reset_index(drop=False)
    ds['total'] = ds[1] + ds[0]
    ds.columns = ['bin', '0', '1', 'total']

    df_ref_table = gene_reference(ds, var_name=var_name, var_type='categorical')
    if to_plot == True:
        plot_reference(df_ref_table, save_path=save_path)

    return df_ref_table


def restore_list(string, value_type):
    '''
    将字符串还原成list，eg:'[1, 2]' → [1,2]
    Args:
        string: str
        var_type: str, 值的类型, numerical or categorical
    Return:
        list
    Raise:
        ValueError
    '''
    if value_type == 'numerical':
        return [float(i.strip('[] ')) for i in string.split(',')]
    elif value_type == 'categorical':
        return string.split('\001')
    else:
        raise ValueError('Wrong value type!')


# def sign(x):
#     '''
#     符号函数，定义sgn(0) = 1
#     '''
#     if x >= 0.0:
#         return 1.0
#     else:
#         return -1.0
# vecsign = np.vectorize(sign)    # 向量化sign函数


# def nvlookup(x, bin_lb, bin_ub, ref_value):
#     '''
#     计算x的woe替换值
#     Args:
#         x: float, 待替换的值
#         bin_lb: array-like, bin的下界
#         bin_ub: array-like, bin的上界
#         ref_value: array-like, 每个bin的woe值
#     Return:
#         woe_value: float, woe值
#     '''
#
#     woe_value = 0.5*((vecsign(x-bin_lb) - vecsign(x-bin_ub))* ref_value).sum()  # 计算woe替换值
#
#     return woe_value


def nvlookup(value, bin_lb, bin_ub, ref_value):
    '''
    查找value的woe替换值
    Args:
        x: float, 待替换的值
        bin_lb: array-like, bin的下界
        bin_ub: array-like, bin的上界
        ref_value: array-like, 每个bin的woe值
    Return:
        woe_value: float, woe值
    '''
    index_keymin = list(map(lambda x: 1 if x <= value else 0, bin_lb))
    index_keymax = list(map(lambda x: 1 if x > value else 0, bin_ub))
    index_key = list(map(lambda x, y: x and y, index_keymin, index_keymax))

    # value能找到对应的区间，返回对应的woe值
    if any(index_key):  # any([0, 1]) = True
        ref = ref_value[index_key.index(1)]
    # value < min 返回min对应的woe第一个取值
    elif value < bin_lb[0]:
        ref = ref_value[0]
    # value > max 返回max对应的woe最后一个取值
    else:
        ref = ref_value[-1]

    return ref


def cvlookup(value, map_dict):
    '''
    查找value的woe替换值
    Args:
        x: str, 待替换的值
        map_dict: dict, woe替换字典
    Return:
        woe_value: float, woe值
    '''
    if value in map_dict.keys():
        woe_value = map_dict[value]
    else:
        woe_value = 0.0

    return woe_value


def numwoe_apply(df_master, ref_table, var_name):
    '''
    对单个numerical变量进行woe替换
    Args:
        df_master: DataFrame
        ref_table: DataFrame, reference table
        var_name: str, 变量名
    Return:
        df_master: DataFrame
    '''
    var_value = ref_table['Var_Value'].apply(lambda x: restore_list(x, 'numerical')).values  # 还原list
    bin_lb = [i[0] for i in var_value]  # bin的下界
    bin_ub = [i[1] for i in var_value]  # bin的上界
    ref_value = ref_table['Ref_Value'].values  # woe值
    df_master['nwoe_' + var_name] = df_master[var_name].apply(lambda x: nvlookup(x, bin_lb, bin_ub, ref_value))

    return df_master


def catwoe_apply(df_master, ref_table, var_name):
    '''
    对单个categorical变量进行woe替换
    Args:
        df_master: DataFrame
        ref_table: DataFrame, reference table
        var_name: str, 变量名
    Return:
        df_master: DataFrame
    '''
    var_value = ref_table['Var_Value'].apply(lambda x: restore_list(x, 'categorical')).values  # 还原list
    df_master[var_name] = df_master[var_name].apply(lambda x: str_convert(x))  # 统一字符编码

    # 构造变量取值的字典
    value_list = []
    ref_value_list = []
    for i, lst in enumerate(var_value):
        value_list += lst
        ref_value_list += [ref_table['Ref_Value'].iloc[i]] * len(lst)
    value_dict = dict(zip(value_list, ref_value_list))

    df_master['cwoe_' + var_name] = df_master[var_name].apply(lambda x: cvlookup(x, value_dict))

    return df_master


def woeref_old2new(ref_woe):
    '''
    将旧版的WOE reference table转成新版
    Args:
        ref_woe: DataFrame, 旧版的WOE reference table
    Return:
        ref_new_woe: DataFrame, 新版的WOE reference table
    '''
    ref_woe_copy = ref_woe.copy()
    ref_woe_copy = ref_woe_copy.loc[ref_woe_copy['Var_Value'] != 'base']
    ref_woe_copy['Total'] = ref_woe_copy['Count_0'] + ref_woe_copy['Count_1']
    ref_woe_copy = ref_woe_copy.rename(columns={'Ratio_1': 'Target_Rate', 'Ratio_All': 'Proportion'})
    ref_woe_copy['Var_Value'] = ref_woe_copy['Var_Value'].apply(lambda x: str(x).split('_'))

    ref_new_woe = ref_woe_copy.groupby(['Var_Name', 'Var_Type', 'IV', 'Ref_Value'], as_index=False, ) \
        .agg({'Var_Value': 'sum', 'Count_0': 'sum', 'Count_1': 'sum', 'Total': 'sum', 'Proportion': 'sum', })

    ref_new_woe['Target_Rate'] = ref_new_woe['Count_1'] / ref_new_woe['Total']

    ref_new_woe['Var_Value'].loc[ref_new_woe['Var_Type'] == 'categorical'] = ref_new_woe['Var_Value'].loc[
        ref_new_woe['Var_Type'] == 'categorical'].apply(lambda x: "\001".join(x))

    ref_new_woe['Bin_No'] = ref_new_woe[['Var_Name', 'Ref_Value']].groupby(['Var_Name']).rank(method='dense',
                                                                                              ascending=True)
    ref_new_woe['Var_Value'] = ref_new_woe['Var_Value'].apply(lambda x: str(x).replace("'", ""))

    return ref_new_woe


def replace_var_woe_ref(woe_ref_all, woe_ref_var):
    '''
    将woe reference table中某个变量的reference替换成新的
    Args:
        woe_ref_all: DataFrame, 所有变量的reference table
        woe_ref_var: DataFrame, 单个变量的reference table
    Return:
        woe_ref_new: DataFrame, 新的reference table
    '''
    replace_var = woe_ref_var['Var_Name'].unique()[0]
    woe_ref_new = woe_ref_all.loc[woe_ref_all['Var_Name'] != replace_var, :].copy()
    woe_ref_new = pd.concat([woe_ref_new, woe_ref_var], axis=0, ignore_index=True)

    return woe_ref_new


def save_pictures_in_excel(file_name, pic_loc, var_list=None, columns_num=1, pic_rows=20, sheet_name='pictures'):
    '''
    将pic_loc里面的图片保存在file_name里面
    Author: jiangjianhong
    Args:
        file_name: string, excel文件名, eg. xxx.xlsx
        pic_loc: string, 存放图片的文件夹路径, string like './woe_graph'
        var_list: list, 需要放入excel的变量列表，不填时会将pic_loc路径下所有的图片都放入excel中，默认为None
        columns_num: int, 分多少列展示
        pic_rows: int, 一张图占多少行
        sheet_name：string, sheet的名字, 默认为'pictures'
    '''
    import xlsxwriter
    if not pic_loc.endswith('/'):
        pic_loc = pic_loc + '/'

    book = xlsxwriter.Workbook(file_name)
    sheet = book.add_worksheet(sheet_name)

    # 生成图片列表
    if var_list is not None:
        pic_list = [pic for pic in os.listdir(pic_loc) if pic.split(".")[-1] in ['jpg', 'png', 'bmp']]
    else:
        pic_list = ['{0}.png'.format(var) for var in var_list]
    pic_list.sort(reverse=True)

    # A到Z的list
    location_list = [i for i in string.ascii_uppercase]

    for i, pic in zip(range(len(pic_list)), pic_list):
        location_x = location_list[(i % columns_num) * 2 + 1]
        if i < columns_num:
            sheet.set_column('{0}:{0}'.format(location_x), 90)  # 设置宽度为90像素

        location_y = pic_rows * (i // columns_num) + 1
        sheet.write('{0}{1}'.format(location_x, location_y), pic)
        sheet.insert_image('{0}{1}'.format(location_x, location_y + 1), pic_loc + pic,
                           options={'x_scale': 0.8, 'y_scale': 0.88})
    book.close()
    print('done')
